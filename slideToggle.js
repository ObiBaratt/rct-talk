/**
 * Toggle the visibility of an element with a slide-in/out animation.
 *
 * @param {Element} element The element to animate.
 * @param {Object} [options] Configuration options.
 * @param {string} [options.direction="right"] Slide direction. Can be "left", "right", "top", or "bottom".
 * @param {number} [options.duration=300] Animation duration in milliseconds.
 * @param {boolean} [options.dim=true] Whether to dim the background while the element is visible.
 * @param {string} [options.width="30%"] Width of the element when visible.
 * @param {string} [options.height="100%"] Height of the element when visible.
 */

function slideToggle(element, options = {}) {
  const defaults = {
    direction: "right",
    duration: 300,
    dim: true,
    width: "30%",
    height: "100%",
  };
  const settings = { ...defaults, ...options };

  const isVisible = !element.classList.contains(
    "_slideHiddenAutogeneratedClass"
  );
  const directionAxis = ["left", "right"].includes(settings.direction)
    ? "X"
    : "Y";
  const sign = ["left", "top"].includes(settings.direction) ? "-" : "";

  // Set initial styles
  if (!element.style.transition) {
    element.style.transition = `transform ${settings.duration}ms ease-in-out`;
  }

  if (isVisible) {
    // Slide out
    element.style.transform = `translate${directionAxis}(${sign}100%)`;
    setTimeout(() => {
      element.classList.add("_slideHiddenAutogeneratedClass");
      element.style.display = "none";
      element.style.transform = "";
    }, settings.duration);

    if (settings.dim) {
        setTimeout(() => {
            removeDimOverlay();
        }, settings.duration + 100); 
    }
  } else {
    // Prepare for slide in
    element.classList.remove("_slideHiddenAutogeneratedClass");
    element.style.display = "block";

    // Set size and position
    element.style.position = "fixed";
    element.style[settings.direction] = "0";
    element.style.width = settings.width;
    element.style.height = settings.height;
    element.style.zIndex = "1000";

    // Force reflow
    element.offsetHeight;

    // Slide in
    element.style.transform = `translate${directionAxis}(${sign}100%)`;
    requestAnimationFrame(() => {
      element.style.transform = "translate(0, 0)";
    });

    if (settings.dim) {
      addDimOverlay(element);
    }
  }
}

function addDimOverlay(element) {
  const overlay = document.createElement("div");
  overlay.className = "_dimOverlayAutogeneratedClass";
  document.body.appendChild(overlay);
  document.body.classList.add("_overlayedAutogeneratedClass");

  overlay.addEventListener("click", () => {
    slideToggle(element);
  });
}

function removeDimOverlay() {
  const overlay = document.querySelector("._dimOverlayAutogeneratedClass");
  if (overlay) {
    overlay.remove();
    document.body.classList.remove("_overlayedAutogeneratedClass");
  }
}

// CSS for the overlay
const style = document.createElement("style");
style.textContent = `
    ._slideHiddenAutogeneratedClass { display: none; }
    ._dimOverlayAutogeneratedClass {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 999;
    }
    ._overlayedAutogeneratedClass { overflow: hidden; }
  `;
document.head.appendChild(style);

export { slideToggle };

const button = document.getElementById("st-button");
const slider = document.getElementById("slider");

button.addEventListener("click", () => {
  slideToggle(slider);
});
